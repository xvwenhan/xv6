①哪些寄存器包含了函数的参数？例如，main 函数中调用 printf 时，哪个寄存器保存了 13？
在 main 函数中，printf("%d %d\n", f(8)+1, 13); 这一行的指令：
  24:	4635                	li	a2,13
可知a2 寄存器包含 13，即第二个参数。
  26:	45b1                	li	a1,12
a1 寄存器包含 12，这是第一个参数 f(8) + 1 的结果。
28: 00000517 auipc a0,0x0 用于加载地址的高位。
2c: 7b050513 addi a0,a0,1968 用于计算完整的地址。
可知a0 寄存器包含 printf 的格式化字符串地址
②在 main 的汇编代码中，在哪一处调用了 f 函数？在哪一处调用了 g 函数？（提示：编译器可能会内联函数。）
在 main 的汇编代码中，f 函数没有显式调用，因为它被编译器内联了。实际上，f(8) 的逻辑已经在 0x24 开始的指令中完成。
类似地，g 函数也没有显式调用，而是被内联在 f 函数中。f 的逻辑是 g(x)，即 x + 3，这直接体现在 addi 指令中（0x14: addiw a0, a0, 3）
③printf 函数位于哪个地址？
printf 函数的实际地址为 0x630（根据提供的注释 # 630 <printf>）
④在 main 函数中，jalr 到 printf 之后，ra 寄存器中的值是什么？
在执行 jalr 指令（0x34：jalr 1536(ra)）之后，ra 寄存器将保存下一条指令的地址，也就是 0x38。这是为了确保在 printf 执行完毕后能够返回到 main 函数的正确位置继续执行。
⑤unsigned int i = 0x00646c72;
printf("H%x Wo%s", 57616, &i);执行结果？
若小端序：57616 用 %x 格式化为 e110。i 的地址指向 0x00646c72，0x72 对应的字符是 r。0x6C 对应的字符是 l。0x64 对应的字符是 d。0x00 是字符串结束标志。因此，i 所指向的内存内容实际表示的字符串是 "rld"。故执行结果为He110 World
如果是大端序,i 的值应设置为 0x726c6400 才能得到相同的输出，因为在大端序中，数据会按高位字节在低地址的顺序存储。但不需要更改 57616 的值，因为它是单独传递的参数，与端序无关。
⑥printf("x=%d y=%d", 3); 代码的输出
打印的输出： 将打印 x=3 y=？（？的值不能确定）
原因： 在调用 printf 时，缺少了第二个参数，因此 printf 函数会在栈上错误地读取下一个未初始化的值，值不能确定。
